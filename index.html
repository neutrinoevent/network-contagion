<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Network Contagion ‚Ä¢ Physics x Networks</title>
  <style>
    html, body { margin:0; height:100%; background:#05060a; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #wrap { height: 100%; display:flex; flex-direction:column; }
    #topbar {
      display:flex; align-items:center; justify-content:space-between;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      background: linear-gradient(180deg, rgba(20,22,35,0.95), rgba(10,10,18,0.35));
      backdrop-filter: blur(10px);
      gap: 12px;
    }
    #title { color: rgba(233,236,255,0.95); font-weight: 750; letter-spacing: 0.3px; }
    #hint { color: rgba(233,236,255,0.55); font-size: 12px; margin-top: 2px; }
    #controls { display:flex; align-items:center; gap: 8px; flex-wrap: wrap; justify-content:flex-end; }
    select, button {
      -webkit-tap-highlight-color: transparent;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(233,236,255,0.92);
      padding: 10px 10px;
      font-size: 13px;
      outline: none;
      backdrop-filter: blur(8px);
    }
    button { cursor: pointer; }
    button:hover { background: rgba(255,255,255,0.10); }
    #container { flex:1; position: relative; }
    #badge {
      position: absolute; left: 12px; bottom: 12px;
      background: rgba(255,255,255,0.07);
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(233,236,255,0.92);
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 12px;
      backdrop-filter: blur(8px);
      user-select: none;
      pointer-events: none;
      white-space: nowrap;
    }
    #error {
      position:absolute; left:12px; top:12px; right:12px;
      padding:10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,120,120,0.35);
      background: rgba(120,20,20,0.28);
      color: rgba(255,220,220,0.95);
      font-size: 12px;
      display:none;
      backdrop-filter: blur(10px);
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <div>
      <div id="title">Network Contagion</div>
      <div id="hint">Tap nodes to inject ‚Ä¢ swipe left/right to change topology ‚Ä¢ pinch to change speed</div>
    </div>
    <div id="controls">
      <select id="variant" aria-label="Network variant"></select>

      <select id="mode" aria-label="Behavior mode">
        <option value="viral">Viral</option>
        <option value="meme">Meme</option>
        <option value="panic">Panic</option>
        <option value="trust">Trust</option>
      </select>

      <button id="inject">‚ö° Inject</button>
      <button id="contain">üõ°Ô∏è Contain</button>
      <button id="rewire">üß¨ Rewire: OFF</button>
      <button id="reset">‚Ü∫ Reset</button>
    </div>
  </div>

  <div id="container">
    <div id="error"></div>
    <div id="badge">Speed: 1.0√ó</div>
  </div>
</div>

<script type="module">
  import Graph from "https://cdn.jsdelivr.net/npm/graphology@0.25.4/+esm";
  import Sigma from "https://cdn.jsdelivr.net/npm/sigma@3.0.1/+esm";

  const COLORS = {
    calm:  "#6f7cff",
    hot:   "#ff3b7a",
    warm:  "#ffb000",
    safe:  "#22e3a2",
    edge:  "rgba(180,190,255,0.14)",
    edgeHot: "rgba(255,59,122,0.85)"
  };

  const BEHAVIORS = {
    viral: { beta: 0.85, recover: 2.3, pulseDecay: 1.8, edgePulseDecay: 2.4 },
    meme:  { beta: 0.55, recover: 5.0, pulseDecay: 1.1, edgePulseDecay: 2.0 },
    panic: { beta: 1.15, recover: 3.0, pulseDecay: 2.2, edgePulseDecay: 2.8 },
    trust: { beta: 0.35, recover: 7.5, pulseDecay: 0.9, edgePulseDecay: 1.6 }
  };

  const container = document.getElementById("container");
  const badge = document.getElementById("badge");
  const errorBox = document.getElementById("error");

  const injectBtn  = document.getElementById("inject");
  const containBtn = document.getElementById("contain");
  const resetBtn   = document.getElementById("reset");
  const rewireBtn  = document.getElementById("rewire");
  const modeSel    = document.getElementById("mode");
  const varSel     = document.getElementById("variant");

  let graph = null;
  let renderer = null;

  // ---- State
  let contained = false;
  let rewiringEnabled = false;

  let simulationSpeed = 1.0; // user-controlled
  let lastFrame = performance.now();
  let accumulator = 0;

  // animation loop control (prevents ‚Äúdead loop after an exception‚Äù)
  let rafId = null;
  let loopStarted = false;
  let loadingVariant = false;

  function showError(msg) {
    errorBox.style.display = "block";
    errorBox.textContent = msg;
  }
  function clearError() {
    errorBox.style.display = "none";
    errorBox.textContent = "";
  }

  // ---- Variants
  const manifest = await fetch("./manifest.json").then(r => r.json());
  const variants = manifest.variants;

  variants.forEach((v, idx) => {
    const opt = document.createElement("option");
    opt.value = String(idx);
    opt.textContent = `${v.label} (${v.nodes}n)`;
    varSel.appendChild(opt);
  });

  function currentBehavior() {
    return BEHAVIORS[modeSel.value] ?? BEHAVIORS.viral;
  }

  function edgeColorFromPulse(p) {
    const a = Math.max(0, Math.min(1, p));
    if (a <= 0.001) return COLORS.edge;
    const hotA = 0.85;
    const baseA = 0.14;
    const alpha = baseA + (hotA - baseA) * a;
    return `rgba(255,59,122,${alpha.toFixed(3)})`;
  }

  function setEdgePulse(u, v, strength=1.0) {
    if (!graph) return;
    const eid = graph.edge(u, v) ?? graph.edge(v, u);
    if (!eid) return;
    graph.mergeEdgeAttributes(eid, {
      pulse: Math.max(graph.getEdgeAttribute(eid, "pulse") || 0, strength)
    });
  }

  function inject(seed=null) {
    if (!graph) return;
    const nodes = graph.nodes();
    if (!nodes.length) return;
    const start = seed ?? nodes[Math.floor(Math.random() * nodes.length)];
    graph.mergeNodeAttributes(start, { state:"I", t:0, pulse:1.0 });
  }

  function resetAll() {
    if (!graph) return;
    graph.forEachNode((n, a) => {
      graph.mergeNodeAttributes(n, {
        state:"S", t:0, pulse:0,
        color: COLORS.calm,
        size: a.baseSize ?? 3.0,
        memory: 0,
        resistance: 0
      });
    });
    graph.forEachEdge((e) => {
      graph.mergeEdgeAttributes(e, { pulse: 0, color: COLORS.edge });
    });
    contained = false;
    containBtn.textContent = "üõ°Ô∏è Contain";
  }

  function updateBadge() {
    badge.textContent = `Speed: ${simulationSpeed.toFixed(1)}√ó`;
  }

  // ---- Load graph variant (safe against tick() running mid-swap)
  async function loadVariant(idx) {
    clearError();
    loadingVariant = true;

    const v = variants[idx];
    const data = await fetch(`./${v.file}`).then(r => r.json());

    // Pause the simulation logic while we swap internals
    accumulator = 0;

    // Kill old renderer safely
    try {
      if (renderer) renderer.kill();
    } catch (e) {
      // ignore
    }
    renderer = null;
    graph = null;

    // Build new graph
    graph = new Graph();

    data.nodes.forEach(n => graph.addNode(n.key, {
      x: n.x, y: n.y,
      baseSize: n.size,
      size: n.size,
      label: n.label,
      color: COLORS.calm,
      state: "S",
      t: 0,
      pulse: 0,
      memory: 0,
      resistance: 0,
      community: n.community ?? 0,
      centrality: n.centrality ?? 0
    }));

    data.edges.forEach(e => {
      // avoid duplicates / bad edges from generation
      if (!graph.hasNode(e.source) || !graph.hasNode(e.target)) return;
      if (graph.hasEdge(e.source, e.target) || graph.hasEdge(e.target, e.source)) return;

      graph.addEdge(e.source, e.target, {
        color: COLORS.edge,
        size: 1,
        pulse: 0,
        weight: e.weight ?? 1.0,

        // IMPORTANT:
        // Do NOT set edge attribute "type" here.
        // Sigma treats it as a render-program key (e.g., "line", "arrow").
        // Your JSON uses type values like "small_world" which crash Sigma.
        kind: e.type ?? "structural"
      });
    });

    // Create sigma
    renderer = new Sigma(graph, container, {
      renderLabels: false,
      allowInvalidContainer: false,
      defaultEdgeColor: COLORS.edge,
      labelRenderedSizeThreshold: 9999
    });

    renderer.on("clickNode", ({ node }) => {
      renderer.getCamera().animate(graph.getNodeAttributes(node), { duration: 420 });
      inject(node);
    });

    // Reset timing so we don't get a huge dt spike
    lastFrame = performance.now();
    accumulator = 0;

    // Instant wow
    inject();

    loadingVariant = false;
  }

  // ---- Mobile swipe to change variant
  let touchStartX = 0;
  let touchStartY = 0;

  container.addEventListener("touchstart", (e) => {
    if (e.touches.length !== 1) return;
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
  }, { passive: true });

  container.addEventListener("touchend", async (e) => {
    if (!touchStartX) return;
    const endX = e.changedTouches[0].clientX;
    const endY = e.changedTouches[0].clientY;
    const dx = endX - touchStartX;
    const dy = endY - touchStartY;
    touchStartX = 0;

    if (Math.abs(dx) > 60 && Math.abs(dy) < 70) {
      const cur = Number(varSel.value);
      const next = dx < 0 ? (cur + 1) % variants.length : (cur - 1 + variants.length) % variants.length;
      varSel.value = String(next);
      await loadVariant(next);
    }
  }, { passive: true });

  // ---- Pinch-to-speed (mobile)
  let pinchStartDist = null;
  let pinchStartSpeed = 1.0;

  function dist2(t0, t1) {
    const dx = t0.clientX - t1.clientX;
    const dy = t0.clientY - t1.clientY;
    return Math.sqrt(dx*dx + dy*dy);
  }

  container.addEventListener("touchstart", (e) => {
    if (e.touches.length === 2) {
      pinchStartDist = dist2(e.touches[0], e.touches[1]);
      pinchStartSpeed = simulationSpeed;
    }
  }, { passive: true });

  container.addEventListener("touchmove", (e) => {
    if (e.touches.length === 2 && pinchStartDist) {
      const d = dist2(e.touches[0], e.touches[1]);
      const ratio = d / pinchStartDist;
      simulationSpeed = Math.max(0.2, Math.min(3.0, pinchStartSpeed * ratio));
      updateBadge();
    }
  }, { passive: true });

  container.addEventListener("touchend", (e) => {
    if (e.touches.length < 2) pinchStartDist = null;
  }, { passive: true });

  // ---- Pinch-to-speed (desktop trackpad pinch often appears as ctrl+wheel)
  container.addEventListener("wheel", (e) => {
    if (!e.ctrlKey) return;
    e.preventDefault();
    simulationSpeed = Math.max(0.2, Math.min(3.0, simulationSpeed + (-e.deltaY) * 0.002));
    updateBadge();
  }, { passive: false });

  updateBadge();

  // ---- Adaptive rewiring (lightweight + capped)
  let rewireCooldown = 0;

  function doAdaptiveRewire(dt) {
    if (!rewiringEnabled || !graph) return;
    rewireCooldown -= dt;
    if (rewireCooldown > 0) return;
    rewireCooldown = 0.25; // only try rewiring 4x/sec

    const maxRewires = 4;
    let rewires = 0;

    const infected = [];
    graph.forEachNode((n, a) => { if (a.state === "I") infected.push(n); });
    if (infected.length < 2) return;

    for (let i = 0; i < infected.length && rewires < maxRewires; i++) {
      const n = infected[Math.floor(Math.random() * infected.length)];
      if (Math.random() > 0.30) continue;

      const edges = graph.edges(n);
      if (edges.length < 2) continue;

      const toDrop = edges[Math.floor(Math.random() * edges.length)];
      const ext = graph.extremities(toDrop);
      graph.dropEdge(toDrop);

      const m = infected[Math.floor(Math.random() * infected.length)];
      if (n !== m && !graph.hasEdge(n, m) && !graph.hasEdge(m, n)) {
        graph.addEdge(n, m, { color: "rgba(255,85,255,0.35)", size: 1, pulse: 0, weight: 1.0, kind: "adaptive" });
        rewires += 1;
      } else {
        graph.addEdge(ext[0], ext[1], { color: COLORS.edge, size: 1, pulse: 0, weight: 1.0, kind: "restored" });
      }
    }
  }

  // ---- Simulation (fixed step with speed multiplier)
  const baseDt = 1 / 60;

  function tick(now) {
    // Always keep the loop alive, but don‚Äôt do work during swaps
    if (loadingVariant || !graph || !renderer) {
      rafId = requestAnimationFrame(tick);
      return;
    }

    try {
      const elapsed = Math.min(0.05, (now - lastFrame) / 1000);
      lastFrame = now;

      accumulator += elapsed * simulationSpeed;

      while (accumulator >= baseDt) {
        step(baseDt);
        accumulator -= baseDt;
      }

      renderer.refresh();
      rafId = requestAnimationFrame(tick);
    } catch (e) {
      showError(
        "Simulation halted due to an error.\n\n" +
        String(e?.stack || e) +
        "\n\nTip: refresh the page. If this persists, we‚Äôll harden the failing section."
      );
      rafId = requestAnimationFrame(tick);
    }
  }

  function step(dt) {
    const { beta, recover, pulseDecay, edgePulseDecay } = currentBehavior();
    const spread = contained ? beta * 0.45 : beta;

    // Mobile-safety throttle: cap how many new infections can occur per step
    const maxNewInfections = 220;

    const newly = [];
    graph.forEachNode((n, a) => {
      if (a.state !== "I") return;
      if (newly.length >= maxNewInfections) return;

      graph.forEachNeighbor(n, (m, am) => {
        if (newly.length >= maxNewInfections) return;
        if (am.state !== "S") return;

        const resist = am.resistance ?? 0;
        const effective = spread * (1 - resist);
        if (Math.random() < effective * dt) {
          newly.push([n, m]);
        }
      });
    });

    newly.forEach(([src, dst]) => {
      graph.mergeNodeAttributes(dst, { state:"I", t:0, pulse:1.0 });
      setEdgePulse(src, dst, 1.0);
    });

    graph.forEachNode((n, a) => {
      let { state, t, pulse } = a;

      t += dt;
      pulse = Math.max(0, pulse - pulseDecay * dt);

      if (state === "S") {
        graph.setNodeAttribute(n, "color", COLORS.calm);
      } else if (state === "I") {
        graph.setNodeAttribute(n, "color", t < 0.6 ? COLORS.hot : COLORS.warm);

        if (t > recover) {
          const mem = (a.memory ?? 0) + 1;
          const resistance = Math.min(0.8, mem * 0.10);
          state = "R";
          t = 0;
          graph.mergeNodeAttributes(n, { memory: mem, resistance });
        }
      } else if (state === "R") {
        graph.setNodeAttribute(n, "color", COLORS.safe);
        if (t > 8.0) { state = "S"; t = 0; }
      }

      const base = a.baseSize ?? 3.0;
      const s = Math.min(base + 2.2 * pulse, base + 3.0);
      graph.mergeNodeAttributes(n, { state, t, pulse, size: s });
    });

    graph.forEachEdge((e, a) => {
      let p = a.pulse ?? 0;
      if (p <= 0) {
        if (a.color !== COLORS.edge && (a.kind ?? "") !== "adaptive") graph.setEdgeAttribute(e, "color", COLORS.edge);
        return;
      }
      p = Math.max(0, p - edgePulseDecay * dt);
      graph.mergeEdgeAttributes(e, { pulse: p, color: edgeColorFromPulse(p) });
    });

    doAdaptiveRewire(dt);
  }

  // ---- Controls
  injectBtn.onclick = () => inject();

  containBtn.onclick = () => {
    contained = !contained;
    containBtn.textContent = contained ? "üõ°Ô∏è Containment: ON" : "üõ°Ô∏è Contain";
  };

  rewireBtn.onclick = () => {
    rewiringEnabled = !rewiringEnabled;
    rewireBtn.textContent = rewiringEnabled ? "üß¨ Rewire: ON" : "üß¨ Rewire: OFF";
  };

  resetBtn.onclick = () => resetAll();

  varSel.onchange = async () => {
    const idx = Number(varSel.value);
    await loadVariant(idx);
  };

  // init + start loop
  await loadVariant(0);
  if (!loopStarted) {
    loopStarted = true;
    rafId = requestAnimationFrame(tick);
  }
</script>
</body>
</html>

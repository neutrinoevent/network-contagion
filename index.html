<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Network Contagion ‚Ä¢ Physics x Networks</title>
  <style>
    html, body { margin:0; height:100%; background:#05060a; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #wrap { height: 100%; display:flex; flex-direction:column; }
    #topbar {
      display:flex; align-items:center; justify-content:space-between;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      background: linear-gradient(180deg, rgba(20,22,35,0.95), rgba(10,10,18,0.35));
      backdrop-filter: blur(10px);
      gap: 12px;
    }
    #title { color: rgba(233,236,255,0.95); font-weight: 750; letter-spacing: 0.3px; }
    #hint { color: rgba(233,236,255,0.55); font-size: 12px; margin-top: 2px; }
    #controls { display:flex; align-items:center; gap: 8px; flex-wrap: wrap; justify-content:flex-end; }
    select, button {
      -webkit-tap-highlight-color: transparent;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(233,236,255,0.92);
      padding: 10px 10px;
      font-size: 13px;
      outline: none;
      backdrop-filter: blur(8px);
    }
    button { cursor: pointer; }
    button:hover { background: rgba(255,255,255,0.10); }
    #container { flex:1; position: relative; min-height: 200px; }
    #badge {
      position: absolute; left: 12px; bottom: 12px;
      background: rgba(255,255,255,0.07);
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(233,236,255,0.92);
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 12px;
      backdrop-filter: blur(8px);
      user-select: none;
      pointer-events: none;
      white-space: nowrap;
    }
    #error {
      position:absolute; left:12px; top:12px; right:12px;
      padding:10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,120,120,0.35);
      background: rgba(120,20,20,0.28);
      color: rgba(255,220,220,0.95);
      font-size: 12px;
      display:none;
      backdrop-filter: blur(10px);
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <div>
      <div id="title">Network Contagion</div>
      <div id="hint">Tap nodes to inject ‚Ä¢ pinch / ctrl+wheel to change speed</div>
    </div>
    <div id="controls">
      <select id="variant" aria-label="Network variant"></select>

      <select id="mode" aria-label="Behavior mode">
        <option value="viral">Viral</option>
        <option value="meme">Meme</option>
        <option value="panic">Panic</option>
        <option value="trust">Trust</option>
      </select>

      <button id="inject">‚ö° Inject</button>
      <button id="contain">üõ°Ô∏è Contain</button>
      <button id="rewire">üß¨ Rewire: OFF</button>
      <button id="reset">‚Ü∫ Reset</button>
    </div>
  </div>

  <div id="container">
    <div id="error"></div>
    <div id="badge">Speed: 1.0√ó</div>
  </div>
</div>

<script type="module">
  import Graph from "https://cdn.jsdelivr.net/npm/graphology@0.25.4/+esm";
  import Sigma from "https://cdn.jsdelivr.net/npm/sigma@3.0.1/+esm";

  const COLORS = {
    calm:  "#6f7cff",
    hot:   "#ff3b7a",
    warm:  "#ffb000",
    safe:  "#22e3a2",
    edge:  "rgba(180,190,255,0.14)"
  };

  // Lower baselines + we ALSO normalize by graph density at runtime.
  const BEHAVIORS = {
    viral: { beta: 0.45, recover: 2.8, pulseDecay: 1.7, edgePulseDecay: 2.1 },
    meme:  { beta: 0.30, recover: 5.8, pulseDecay: 1.05, edgePulseDecay: 1.85 },
    panic: { beta: 0.60, recover: 3.4, pulseDecay: 2.0, edgePulseDecay: 2.4 },
    trust: { beta: 0.18, recover: 8.5, pulseDecay: 0.9, edgePulseDecay: 1.45 }
  };

  const container = document.getElementById("container");
  const badge = document.getElementById("badge");
  const errorBox = document.getElementById("error");

  const injectBtn  = document.getElementById("inject");
  const containBtn = document.getElementById("contain");
  const resetBtn   = document.getElementById("reset");
  const rewireBtn  = document.getElementById("rewire");
  const modeSel    = document.getElementById("mode");
  const varSel     = document.getElementById("variant");

  let graph = null;
  let renderer = null;

  // ---- State
  let contained = false;
  let rewiringEnabled = false;

  let simulationSpeed = 1.0;
  let lastFrame = performance.now();
  let accumulator = 0;

  let rafId = null;
  let loopStarted = false;
  let loadingVariant = false;

  // Density stats per loaded graph
  let avgDegree = 6;      // updated on load
  let degreeScale = 1.0;  // updated on load

  function showError(msg) {
    errorBox.style.display = "block";
    errorBox.textContent = msg;
  }
  function clearError() {
    errorBox.style.display = "none";
    errorBox.textContent = "";
  }

  function updateBadge() {
    badge.textContent = `Speed: ${simulationSpeed.toFixed(1)}√ó`;
  }

  function currentBehavior() {
    return BEHAVIORS[modeSel.value] ?? BEHAVIORS.viral;
  }

  function edgeColorFromPulse(p) {
    const a = Math.max(0, Math.min(1, p));
    if (a <= 0.001) return COLORS.edge;
    const hotA = 0.85;
    const baseA = 0.14;
    const alpha = baseA + (hotA - baseA) * a;
    return `rgba(255,59,122,${alpha.toFixed(3)})`;
  }

  function setEdgePulse(u, v, strength=1.0) {
    if (!graph) return;
    const eid = graph.edge(u, v) ?? graph.edge(v, u);
    if (!eid) return;
    graph.mergeEdgeAttributes(eid, {
      pulse: Math.max(graph.getEdgeAttribute(eid, "pulse") || 0, strength)
    });
  }

  function inject(seed=null) {
    if (!graph) return;
    const nodes = graph.nodes();
    if (!nodes.length) return;
    const start = seed ?? nodes[Math.floor(Math.random() * nodes.length)];
    graph.mergeNodeAttributes(start, { state:"I", t:0, pulse:1.0 });
  }

  function resetAll() {
    if (!graph) return;
    graph.forEachNode((n, a) => {
      graph.mergeNodeAttributes(n, {
        state:"S", t:0, pulse:0,
        color: COLORS.calm,
        size: a.baseSize ?? 3.0,
        memory: 0,
        resistance: 0
      });
    });
    graph.forEachEdge((e) => {
      graph.mergeEdgeAttributes(e, { pulse: 0, color: COLORS.edge, size: 1 });
    });

    contained = false;
    containBtn.textContent = "üõ°Ô∏è Contain";

    // (optional) keep rewiring state as-is; comment out next 2 lines if you prefer reset to disable it
    // rewiringEnabled = false;
    // rewireBtn.textContent = "üß¨ Rewire: OFF";
  }

  // ---- Variants
  const manifest = await fetch("./manifest.json").then(r => r.json());
  const variants = manifest.variants;

  variants.forEach((v, idx) => {
    const opt = document.createElement("option");
    opt.value = String(idx);
    opt.textContent = `${v.label} (${v.nodes}n)`;
    varSel.appendChild(opt);
  });

  // ---- Load graph variant
  async function loadVariant(idx) {
    clearError();
    loadingVariant = true;

    const v = variants[idx];
    const data = await fetch(`./${v.file}`).then(r => r.json());

    accumulator = 0;

    try { if (renderer) renderer.kill(); } catch (e) {}
    renderer = null;
    graph = null;

    graph = new Graph();

    data.nodes.forEach(n => graph.addNode(n.key, {
      x: n.x, y: n.y,
      baseSize: n.size,
      size: n.size,
      label: n.label,
      color: COLORS.calm,
      state: "S",
      t: 0,
      pulse: 0,
      memory: 0,
      resistance: 0,
      community: n.community ?? 0,
      centrality: n.centrality ?? 0
    }));

    data.edges.forEach(e => {
      if (!graph.hasNode(e.source) || !graph.hasNode(e.target)) return;
      if (graph.hasEdge(e.source, e.target) || graph.hasEdge(e.target, e.source)) return;

      // IMPORTANT: do NOT set edge attribute "type" (Sigma uses it as a WebGL program key)
      graph.addEdge(e.source, e.target, {
        color: COLORS.edge,
        size: 1,
        pulse: 0,
        weight: e.weight ?? 1.0,
        kind: e.type ?? "structural"
      });
    });

    // Compute density normalization:
    // avgDegree = 2E/N (undirected) approximately, but graphology can compute directly.
    let degSum = 0;
    graph.forEachNode((n) => { degSum += graph.degree(n); });
    avgDegree = degSum / Math.max(1, graph.order);

    // We target ‚Äúreadable‚Äù spread around avgDegree ~ 6.
    // Dense graphs => scale down beta, sparse graphs => scale up a bit (clamped).
    degreeScale = 6 / Math.max(1, avgDegree);
    degreeScale = Math.max(0.35, Math.min(1.35, degreeScale));

renderer = new Sigma(graph, container, {
  renderLabels: false,
  allowInvalidContainer: false,
  defaultEdgeColor: COLORS.edge,
  labelRenderedSizeThreshold: 9999,

  // Prevent ‚Äútap causes drift‚Äù from touch dragging/panning
  enableCamera: false
});


    // FIX: camera jump ‚Äî animate ONLY x,y (+ keep ratio), and do it after a refresh.
renderer.on("clickNode", ({ node }) => {
  inject(node);
});


    lastFrame = performance.now();
    accumulator = 0;

    resetAll();
    inject(); // instant ‚Äúwow‚Äù seed

    loadingVariant = false;
  }

  // ---- Pinch-to-speed (mobile)
  let pinchStartDist = null;
  let pinchStartSpeed = 1.0;

  function dist2(t0, t1) {
    const dx = t0.clientX - t1.clientX;
    const dy = t0.clientY - t1.clientY;
    return Math.sqrt(dx*dx + dy*dy);
  }

  container.addEventListener("touchstart", (e) => {
    if (e.touches.length === 2) {
      pinchStartDist = dist2(e.touches[0], e.touches[1]);
      pinchStartSpeed = simulationSpeed;
    }
  }, { passive: true });

  container.addEventListener("touchmove", (e) => {
    if (e.touches.length === 2 && pinchStartDist) {
      const d = dist2(e.touches[0], e.touches[1]);
      const ratio = d / pinchStartDist;
      simulationSpeed = Math.max(0.2, Math.min(3.0, pinchStartSpeed * ratio));
      updateBadge();
    }
  }, { passive: true });

  container.addEventListener("touchend", (e) => {
    if (e.touches.length < 2) pinchStartDist = null;
  }, { passive: true });

  // ---- ctrl+wheel (desktop pinch)
  container.addEventListener("wheel", (e) => {
    if (!e.ctrlKey) return;
    e.preventDefault();
    simulationSpeed = Math.max(0.2, Math.min(3.0, simulationSpeed + (-e.deltaY) * 0.002));
    updateBadge();
  }, { passive: false });

  updateBadge();

  // ---- Adaptive rewiring (lightweight + capped)
  let rewireCooldown = 0;

  function doAdaptiveRewire(dt) {
    if (!rewiringEnabled || !graph) return;
    rewireCooldown -= dt;
    if (rewireCooldown > 0) return;
    rewireCooldown = 0.30;

    const maxRewires = 3;
    let rewires = 0;

    const infected = [];
    graph.forEachNode((n, a) => { if (a.state === "I") infected.push(n); });
    if (infected.length < 2) return;

    for (let i = 0; i < infected.length && rewires < maxRewires; i++) {
      const n = infected[Math.floor(Math.random() * infected.length)];
      if (Math.random() > 0.25) continue;

      const edges = graph.edges(n);
      if (edges.length < 2) continue;

      const toDrop = edges[Math.floor(Math.random() * edges.length)];
      const ext = graph.extremities(toDrop);
      graph.dropEdge(toDrop);

      const m = infected[Math.floor(Math.random() * infected.length)];
      if (n !== m && !graph.hasEdge(n, m) && !graph.hasEdge(m, n)) {
        graph.addEdge(n, m, { color: "rgba(255,85,255,0.30)", size: 1, pulse: 0, weight: 1.0, kind: "adaptive" });
        rewires += 1;
      } else {
        graph.addEdge(ext[0], ext[1], { color: COLORS.edge, size: 1, pulse: 0, weight: 1.0, kind: "restored" });
      }
    }
  }

  // ---- Simulation (fixed step)
  const baseDt = 1 / 60;

  function tick(now) {
    if (loadingVariant || !graph || !renderer) {
      rafId = requestAnimationFrame(tick);
      return;
    }

    try {
      const elapsed = Math.min(0.05, (now - lastFrame) / 1000);
      lastFrame = now;

      accumulator += elapsed * simulationSpeed;

      while (accumulator >= baseDt) {
        step(baseDt);
        accumulator -= baseDt;
      }

      renderer.refresh();
      rafId = requestAnimationFrame(tick);
    } catch (e) {
      showError(
        "Simulation halted due to an error.\n\n" +
        String(e?.stack || e) +
        "\n\nTip: refresh the page."
      );
      rafId = requestAnimationFrame(tick);
    }
  }

  function step(dt) {
    const { beta, recover, pulseDecay, edgePulseDecay } = currentBehavior();

    // Normalize by density so variants feel consistent:
    // contained reduces spread further
    const baseSpread = (contained ? beta * 0.45 : beta) * degreeScale;

    // Cap new infections per step relative to N (prevents ‚Äúinstant full infection‚Äù on dense graphs)
    const maxNewInfections = Math.max(40, Math.floor(graph.order * 0.04)); // ~4% per step cap

    const newly = [];

graph.forEachNode((n, a) => {
  if (a.state !== "I") return;
  if (newly.length >= maxNewInfections) return;

  const deg = Math.max(1, graph.degree(n));
  const hubDamp = 1 / Math.sqrt(deg);
  const localSpread = baseSpread * hubDamp;

  let infectedThisStep = 0;
  const perNodeCap = 2; // <- big stabilizer across variants

  graph.forEachNeighbor(n, (m, am) => {
    if (newly.length >= maxNewInfections) return;
    if (infectedThisStep >= perNodeCap) return;
    if (am.state !== "S") return;

    const resist = am.resistance ?? 0;
    const effective = localSpread * (1 - resist);

    if (Math.random() < effective * dt) {
      newly.push([n, m]);
      infectedThisStep += 1;
    }
  });
});


    newly.forEach(([src, dst]) => {
      graph.mergeNodeAttributes(dst, { state:"I", t:0, pulse:1.0 });
      setEdgePulse(src, dst, 1.0);
    });

    graph.forEachNode((n, a) => {
      let { state, t, pulse } = a;

      t += dt;
      pulse = Math.max(0, pulse - pulseDecay * dt);

      if (state === "S") {
        graph.setNodeAttribute(n, "color", COLORS.calm);
      } else if (state === "I") {
        graph.setNodeAttribute(n, "color", t < 0.6 ? COLORS.hot : COLORS.warm);

        if (t > recover) {
          const mem = (a.memory ?? 0) + 1;
          const resistance = Math.min(0.8, mem * 0.10);
          state = "R";
          t = 0;
          graph.mergeNodeAttributes(n, { memory: mem, resistance });
        }
      } else if (state === "R") {
        graph.setNodeAttribute(n, "color", COLORS.safe);
        if (t > 8.0) { state = "S"; t = 0; }
      }

      const base = a.baseSize ?? 3.0;
      const s = Math.min(base + 2.2 * pulse, base + 3.0);
      graph.mergeNodeAttributes(n, { state, t, pulse, size: s });
    });

    graph.forEachEdge((e, a) => {
      let p = a.pulse ?? 0;
      if (p <= 0) {
        if (a.color !== COLORS.edge && (a.kind ?? "") !== "adaptive") graph.setEdgeAttribute(e, "color", COLORS.edge);
        return;
      }
      p = Math.max(0, p - edgePulseDecay * dt);
      graph.mergeEdgeAttributes(e, { pulse: p, color: edgeColorFromPulse(p) });
    });

    doAdaptiveRewire(dt);
  }

  // ---- Controls
  injectBtn.onclick = () => inject();

  containBtn.onclick = () => {
    contained = !contained;
    containBtn.textContent = contained ? "üõ°Ô∏è Containment: ON" : "üõ°Ô∏è Contain";
  };

  rewireBtn.onclick = () => {
    rewiringEnabled = !rewiringEnabled;
    rewireBtn.textContent = rewiringEnabled ? "üß¨ Rewire: ON" : "üß¨ Rewire: OFF";
  };

  resetBtn.onclick = () => resetAll();

  varSel.onchange = async () => {
    const idx = Number(varSel.value);
    await loadVariant(idx);
  };

  // init + loop
  await loadVariant(0);
  if (!loopStarted) {
    loopStarted = true;
    rafId = requestAnimationFrame(tick);
  }
</script>
</body>
</html>
